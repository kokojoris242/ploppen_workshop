<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Trail Effect</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: transparent;
            min-height: 100vh;
            overflow: hidden;
        }

        .content {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: none;
        }

        .content__img {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0;
        }

        .content__img-inner {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .cursor {
            position: fixed;
            width: 10px;
            height: 10px;
            border: 1px solid #333;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
        }
    </style>
</head>
<body>
    <div class="content" id="container"></div>
    <div class="cursor" id="cursor"></div>

    <script>
        const images = [
            { type: 'image', src: 'images/001.jpg', aspectRatio: 9/16 },
            { type: 'image', src: 'images/002.jpg', aspectRatio: 3/4 },
            { type: 'image', src: 'images/003.jpg', aspectRatio: 9/16 },
            { type: 'image', src: 'images/004.jpg', aspectRatio: 3/4 },
            { type: 'image', src: 'images/006.jpg', aspectRatio: 3/4 },
            { type: 'image', src: 'images/007.jpg', aspectRatio: 1/1 }
        ];

        function lerp(a, b, n) {
            return (1 - n) * a + n * b;
        }

        function getLocalPointerPos(e, rect) {
            let clientX = 0, clientY = 0;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function getMouseDistance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.hypot(dx, dy);
        }

        const cursor = document.getElementById('cursor');
        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        });

        class ImageItem {
            constructor(el) {
                this.DOM = { el: el, inner: el.querySelector('.content__img-inner') };
                this.defaultStyle = { scale: 1, x: 0, y: 0, opacity: 0 };
                this.getRect();
                window.addEventListener('resize', () => {
                    gsap.set(this.DOM.el, this.defaultStyle);
                    this.getRect();
                });
            }
            getRect() {
                this.rect = this.DOM.el.getBoundingClientRect();
            }
        }

        class ImageTrailBase {
            constructor(container) {
                this.container = container;
                this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img));
                this.imagesTotal = this.images.length;
                this.imgPosition = 0;
                this.zIndexVal = 1;
                this.activeImagesCount = 0;
                this.isIdle = true;
                this.threshold = 80;
                this.mousePos = { x: 0, y: 0 };
                this.lastMousePos = { x: 0, y: 0 };
                this.cacheMousePos = { x: 0, y: 0 };

                const handlePointerMove = ev => {
                    const rect = container.getBoundingClientRect();
                    this.mousePos = getLocalPointerPos(ev, rect);
                };
                container.addEventListener('mousemove', handlePointerMove);
                container.addEventListener('touchmove', handlePointerMove);

                const initRender = ev => {
                    const rect = container.getBoundingClientRect();
                    this.mousePos = getLocalPointerPos(ev, rect);
                    this.cacheMousePos = { ...this.mousePos };
                    requestAnimationFrame(() => this.render());
                    container.removeEventListener('mousemove', initRender);
                    container.removeEventListener('touchmove', initRender);
                };
                container.addEventListener('mousemove', initRender);
                container.addEventListener('touchmove', initRender);
            }

            render() {
                let distance = getMouseDistance(this.mousePos, this.lastMousePos);
                this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);
                this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);

                if (distance > this.threshold) {
                    this.showNextImage();
                    this.lastMousePos = { ...this.mousePos };
                }
                if (this.isIdle && this.zIndexVal !== 1) this.zIndexVal = 1;
                requestAnimationFrame(() => this.render());
            }

            showNextImage() {
                ++this.zIndexVal;
                this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
                const img = this.images[this.imgPosition];
                gsap.killTweensOf(img.DOM.el);

                gsap.timeline({
                    onStart: () => { this.activeImagesCount++; this.isIdle = false; },
                    onComplete: () => { 
                        this.activeImagesCount--; 
                        if (this.activeImagesCount === 0) this.isIdle = true;
                    }
                })
                .fromTo(img.DOM.el, {
                    opacity: 1, scale: 1, zIndex: this.zIndexVal,
                    x: this.cacheMousePos.x - img.rect.width / 2,
                    y: this.cacheMousePos.y - img.rect.height / 2
                }, {
                    duration: 0.6,
                    ease: 'power1',
                    x: this.mousePos.x - img.rect.width / 2,
                    y: this.mousePos.y - img.rect.height / 2
                }, 0)
                .to(img.DOM.el, { 
                    duration: 0.8, 
                    ease: 'power3', 
                    opacity: 0, 
                    scale: 0.2 
                }, 1.2);
            }
        }

        const container = document.getElementById('container');
        const baseHeight = 240;
        
        images.forEach(item => {
            const div = document.createElement('div');
            div.className = 'content__img';
            
            const width = baseHeight * item.aspectRatio;
            div.style.width = width + 'px';
            div.style.height = baseHeight + 'px';
            
            if (item.type === 'video') {
                div.innerHTML = `<div class="content__img-inner"><video src="${item.src}" muted loop></video></div>`;
            } else {
                div.innerHTML = `<div class="content__img-inner" style="background-image: url(${item.src})"></div>`;
            }
            
            container.appendChild(div);
        });

        let currentTrail = new ImageTrailBase(container);
    </script>
</body>
</html>
